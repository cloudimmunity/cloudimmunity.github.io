<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>security - Devs ♥ Security</title><description>Code, Security, and Everything in Between.</description><link>http://localhost:2368/</link><generator>Ghost 0.5</generator><lastBuildDate>Fri, 01 May 2015 02:27:36 GMT</lastBuildDate><atom:link href="http://localhost:2368/tag/security/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Hacking (old) Hacker News: fun with weak passwords and Arc</title><description>&lt;p&gt;When I was conducting my cloud password security research I also looked at &lt;a href="https://news.ycombinator.com/"&gt;Hacker News&lt;/a&gt;. It's not a cloud application, but it does have pretty common password security qualities. It's also interesting because it's written in Arc (a Lisp dialect) and the code is available (the old version from 2009).&lt;br&gt; &lt;br&gt;
When you create a Hacker News account you can create passwords 4 characters long without any restrictions on the password complexity. This mean that you can have a password that looks like 0000 or 1111. Sure, not everybody will use passwords like that, but there's a good chance that quite a few users will have pretty simple passwords. Even technical people are still people and people choose the easiest possible passwords (when they can) making it easy to conduct online password attacks.&lt;br&gt; &lt;br&gt;
What's interesting is that when you change your password you are required to have, at least, 8 characters (still without any complexity requirements). The Arc source code shows that it used to be 4 characters as well. Time to look at the code to see what else might be there...&lt;/p&gt;

&lt;p&gt;Here's the login code from app.arc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def good-login (user pw ip)
  (let record (list (seconds) ip user)
    (if (and user pw (aand (shash pw) (is it (hpasswords* user))))
        (do (unless (user-&amp;gt;cookie* user) (cook-user user))
            (enq-limit record good-logins*)
            user)
        (do (enq-limit record bad-logins*)
            nil))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting part is &lt;code&gt;(aand (shash pw) (is it (hpasswords* user)))&lt;/code&gt; where &lt;br&gt;
the password parameter is hashed and then compared to the expected hash for the user. What makes it interesting is the &lt;code&gt;is&lt;/code&gt; operator that determines if two values in Arc are equal. Let's find out what &lt;code&gt;is&lt;/code&gt; really means...&lt;/p&gt;

&lt;p&gt;&lt;code&gt;is&lt;/code&gt; is defined in ac.scm as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(xdef is (lambda args (pairwise ar-is2 args)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ar-is2&lt;/code&gt; is the function that implements the interesting parts we care about:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define (ar-is2 a b)
  (tnil (or (eqv? a b)
            (and (string? a) (string? b) (string=? a b))
            (and (ar-false? a) (ar-false? b)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important part here is this bit of Scheme code &lt;code&gt;(string=? a b)&lt;/code&gt; that checks if two strings are equal.&lt;/p&gt;

&lt;p&gt;Here's how MzScheme defines its string compare operator "string=?":&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GEN_STRING_COMP(string_eq, "string=?", mz_char_strcmp, ==, 0, 1)
...
static int mz_char_strcmp(const char *who, const mzchar *str1, int l1, const mzchar *str2, int l2, 
        int use_locale, int size_shortcut)
{
  int endres;

  if (size_shortcut &amp;amp;&amp;amp; (l1 != l2))
    return 1;
  //... (cut unused locale compare)
  if (l1 &amp;gt; l2) {
    l1 = l2;
    endres = 1;
  } else {
    if (l2 &amp;gt; l1)
      endres = -1;
    else
      endres = 0;
  }

  while (l1--) {
    unsigned int a, b;

    a = *(str1++);
    b = *(str2++);

    a = a - b;
    if (a)
      return a;
  }

  return endres;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a standard string compare implementation that returns as soon as the current characters don't match. This means that the password checking code is vulnerable to timing attacks (in theory). It's harder to exploit because the code doesn't compare raw/cleartext passwords. Instead, the code compares password hashes, so there's an extra step where you have to generate hash collisions. Depending on the hash algorithm generating hash collisions could be time consuming.&lt;/p&gt;

&lt;p&gt;What are those hashes and what algorithm is used to generate them? The answer is in the &lt;code&gt;shash&lt;/code&gt; function in app.arc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def shash (str)
  (let fname (+ "/tmp/shash" (rand-string 10))
    (w/outfile f fname (disp str f))
    (let res (tostring (system (+ "openssl dgst -sha1 &amp;lt;" fname)))
      (do1 (cut res 0 (- (len res) 1))
           (rmfile fname)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shash&lt;/code&gt; creates a SHA1 hash (without a "salt") and that hash is used to verify the user identity. Compared to MD5 generating SHA1 hash collisions is much more difficult (and not very practical at this point in time).&lt;/p&gt;

&lt;p&gt;The publicly available code is from 2009 and the current password management and processing code has been improved since then (Paul Graham was nice enough to confirm it :-)). It sounds like the current unreleased version might be using a pure Scheme implementation of bcrypt. It would be great to see it given that there aren't a lot of pure Scheme bcrypt implementations out there. In the meantime you can explore an inner hacker inside you and deploy the old code yourself.&lt;/p&gt;

&lt;p&gt;To run Arc 3.0:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Install &lt;a href="http://download.plt-scheme.org/v372.html"&gt;MzScheme v372&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Get &lt;a href="http://ycombinator.com/arc/arc3.tar"&gt;Arc3&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Read the instructions in "how-to-run-news" :-)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To run Arc 3.1:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Install Racket.&lt;/li&gt;
&lt;li&gt;Get &lt;a href="http://ycombinator.com/arc/arc3.1.tar"&gt;Arc3.1&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="https://news.ycombinator.com/"&gt;Hacker News&lt;/a&gt; is not alone when it comes to no password complexity requirements. Quite a few companies have the same password qualities (see &lt;a href="http://localhost:2368/the-sad-state-of-password-security-in-the-cloud"&gt;"The Sad State of Password Security in the Cloud"&lt;/a&gt; to learn more about it). Unlike Hacker News, where you don't gain much by compromising users (unless they reuse the password in other more valuable internet sites or cloud apps), other companies do have valuable information that should be protected a little better.&lt;/p&gt;</description><link>http://localhost:2368/hacking-old-hacker-news-fun-with-weak-passwords-and-arc/</link><guid isPermaLink="false">934c53b9-9db9-423a-98ac-5935e2d1fda8</guid><category>passwords</category><category>security</category><category>Arc</category><category>Lisp</category><dc:creator>Kyle Quest</dc:creator><pubDate>Sat, 27 Dec 2014 17:34:13 GMT</pubDate></item><item><title>The Sad State of Password Security in the Cloud</title><description>&lt;p&gt;When it comes to information security, the harsh reality is that end users are often the weakest link in the chain. It's no surprise then that end users are often first to be exploited by attackers. The cloud and SaaS applications are great targets for these attacks because those applications have to deal with password-based user identities and because they are accessible from anywhere in the world.&lt;br&gt; &lt;br&gt;
A lot has been written about passwords in general and about the weaknesses in many high profile Internet and cloud applications. The security compromises of Evernote, LinkedIn, Sony, Yahoo, Linode, eHarmony, Last.fm, Zappos, Nvidia, Gawker, Billabong, Android Forums, and Ubuntu Forums in the recent years bring new light to a very old problem: People choose weak passwords. They do it because it's easy and because they can. Discussions in the technical community tend to focus on the easy problems: using more appropriate hashing algorithms, using salts for password hashing, etc. Of course, keeping the password hashes safe and using slow hashing algorithms (with random salt values) is important. It would protect a lot of relatively strong passwords that can't be cracked using online brute-forcing attacks from being cracked by using offline brute-forcing attacks.  However, secure password storage and proper password hashing are only one side of the problem. Even if the apps are not compromised, their users are still in danger.&lt;/p&gt;

&lt;p&gt;It's all because they don't do a good job helping their users pick safe passwords. When users pick "password" or "123456", it doesn't matter how secure the password storage and password hashing are because attackers will guess these passwords in no time. It's common practice for Internet and cloud application vendors to say that users shouldn't pick weak passwords. But telling people to pick secure and hard-to-guess passwords simply doesn't work because in many cases people will pick the easiest password their cloud applications allow. The leaked passwords from the recently publicized compromises are great examples of that.&lt;/p&gt;

&lt;p&gt;I wanted to see what popular cloud services and applications do when it comes to making sure their users have secure passwords. I reviewed more than 200 cloud and SaaS services and the results were a bit unexpected.&lt;/p&gt;

&lt;div class="row-fluid"&gt;  
&lt;div id="cloud-service-categories"&gt;  
&lt;h4&gt;Cloud Service Categories (&lt;a href="javascript:dc.filterAll(); dc.renderAll();"&gt;Reset Stats&lt;/a&gt;)&lt;/h4&gt;  
&lt;/div&gt;  

&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;

&lt;div class="row-fluid"&gt;  
&lt;div id="password-requirements"&gt;  
&lt;h4&gt; Password Requirements&lt;/h4&gt;  
&lt;/div&gt;  

&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;

&lt;div class="row-fluid"&gt;  
&lt;h4&gt;Cloud Service Password Requirements&lt;/h4&gt;  
&lt;table class="table table-hover table-bordered table-condensed" id="cloud-service-category-table"&gt;  
&lt;thead&gt;  
&lt;tr class="header"&gt;  
&lt;th&gt;Category&lt;/th&gt;  
&lt;th&gt;Requirement&lt;/th&gt;  
&lt;th&gt;Services&lt;/th&gt;  
&lt;/tr&gt;  
&lt;/thead&gt;  
&lt;/table&gt;  
&lt;/div&gt;

&lt;p&gt;A lot of these cloud services target very technical users, and you'd expect these services to be strict with passwords. You'd also expect the security related services and the services dealing with financial information to have the most secure passwords. But the password requirements below show that the majority of the cloud services allow very simple passwords with any characters, and most of those passwords are allowed to be very short. This means that attackers can easily crack many user passwords using simple online password guessing attacks without compromising the cloud applications and gaining access to password hashes.&lt;/p&gt;

&lt;p&gt;The research produced a number of interesting questions about the password security practices among the different cloud services. How is it that so many services allow single character passwords? Shouldn't services dealing with payments and billing information be really strict about their password requirements? Shouldn't the security, and especially the Identity Management and the authentication services, do best when it comes to password security?&lt;/p&gt;

&lt;p&gt;In most cases, passwords are the "elephant in the room", an issue that's commonly overlooked. Sometimes developers are afraid to impact the user experience in a negative way, but a lot of times only a bare minimum is done because security is at the bottom of the developers' to-do list and the user account implementation often ends up being based on the code samples found on the Internet.&lt;/p&gt;

&lt;p&gt;Unfortunately, the security community and the security/compliance standards don't help that much. Historically, short passwords with random characters have been considered to be the best practice when it comes to password security. This doesn’t work because people can't create and remember passwords like that. It gets worse when people are forced to change their passwords every three months (and in some cases every month). This means that people pick a really easy-to-guess password creation scheme. The standards and the password security best practices try to enforce the password randomness using primitive password restrictions, which ultimately fails because, in most cases, people pick simple words, changing them just enough to satisfy the restrictions. Attackers use these behaviors as a blueprint for password cracking and brute-forcing, turning the application password policies against the victims.&lt;/p&gt;

&lt;p&gt;Everyone accepts we're moving to a future where individuals and organizations will use a large number of discrete applications and services; we need to start thinking about how the building blocks of applications — among them security and password protection — can best be tailored to deliver the needs of this new world. Ideally, it would be great to replace password-based user identities with something else. Unfortunately passwords are like roaches — they'll outlive us all. Instead of living in a fantasy or pretending that the problem doesn't exist and pushing the responsibility for password security on cloud application users, we need correct password security implementations, and we need innovation to make passwords safe and usable.&lt;/p&gt;

&lt;script type="text/javascript" src="http://localhost:2368/assets/js/posts/pstats.js"&gt;&lt;/script&gt;</description><link>http://localhost:2368/the-sad-state-of-password-security-in-the-cloud/</link><guid isPermaLink="false">16afc5ef-fb86-4b47-93de-02a6a671e858</guid><category>passwords</category><category>security</category><category>cloud</category><dc:creator>Kyle Quest</dc:creator><pubDate>Mon, 22 Dec 2014 04:32:47 GMT</pubDate></item></channel></rss>